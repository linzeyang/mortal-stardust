"""
Solution Management API Endpoints

This module provides FastAPI endpoints for managing AI-generated solutions that
are created through the three-stage processing pipeline. Solutions are linked
to specific experiences and provide personalized guidance and actionable steps.

Key Features:
- Retrieval of solutions by experience with stage ordering
- User feedback and rating system for solution quality
- Automatic solution regeneration based on low ratings
- Encrypted storage of sensitive solution content and feedback

Solution Lifecycle:
1. Solutions are generated by AI processing pipeline (stages 1-3)
2. Users can retrieve solutions for their experiences
3. Users provide ratings and feedback on solution quality
4. Low-rated solutions trigger regeneration process
5. Feedback data improves future AI processing

Security Considerations:
- All solution content and user feedback is encrypted at rest
- User isolation - users can only access solutions for their experiences
- Rating data is used for analytics while preserving privacy
"""

from datetime import datetime
from typing import List

from bson import ObjectId
from fastapi import APIRouter, Depends, HTTPException, status

from ..api.auth import get_current_user
from ..core.database import get_solutions_collection
from ..models.solution import RateSolutionRequest
from ..utils.field_encryption import decrypt_solution_data, encrypt_solution_data

router = APIRouter()


@router.get("/experience/{experience_id}", response_model=List[dict])
async def get_solutions_for_experience(
    experience_id: str, current_user: dict = Depends(get_current_user)
):
    """
    Retrieve all AI-generated solutions for a specific user experience.

    This endpoint returns solutions from all three processing stages (healing,
    practical solutions, follow-up) for a given experience. Solutions are
    returned in stage order to maintain the logical flow of the AI processing.

    Authentication:
        Requires valid JWT token in Authorization header

    Args:
        experience_id (str): Unique identifier of the experience
        current_user (dict): Authenticated user object injected by dependency

    Returns:
        List[dict]: List of solution objects ordered by processing stage:
            - id (str): Solution unique identifier
            - experienceId (str): Associated experience ID
            - stage (int): Processing stage (1=healing, 2=practical, 3=follow-up)
            - content (dict): AI-generated solution content
            - aiModel (str): AI model used for generation
            - processingMetadata (dict): Generation parameters and context
            - userFeedback (dict, optional): User rating and feedback
            - createdAt (datetime): Generation timestamp
            - updatedAt (datetime): Last modification timestamp

    Raises:
        HTTPException: 401 if authentication fails
        HTTPException: 404 if experience not found or access denied
        HTTPException: 422 if experience_id format is invalid
        HTTPException: 500 if database operation fails

    Business Rules:
        - Users can only access solutions for their own experiences
        - Solutions are returned in processing stage order (1, 2, 3)
        - Empty list returned if no solutions exist for the experience
        - All sensitive solution content is decrypted for authorized user

    Processing Stages:
        - Stage 1: Psychological healing and emotional support
        - Stage 2: Practical solutions with actionable steps
        - Stage 3: Follow-up tracking and experience supplementation

    Example Request:
        GET /api/solutions/experience/507f1f77bcf86cd799439011

    Example Response:
        [
            {
                "id": "507f1f77bcf86cd799439012",
                "experienceId": "507f1f77bcf86cd799439011",
                "stage": 1,
                "content": {
                    "healing": "It's completely normal to feel anxious...",
                    "emotionalSupport": "Your feelings are valid...",
                    "copingStrategies": ["Deep breathing", "Positive self-talk"]
                },
                "aiModel": "gpt-4",
                "processingMetadata": {
                    "promptVersion": "v2.1",
                    "temperature": 0.7
                },
                "userFeedback": {
                    "rating": 85,
                    "isHelpful": true,
                    "ratedAt": "2024-01-15T16:00:00Z"
                },
                "createdAt": "2024-01-15T15:30:00Z",
                "updatedAt": "2024-01-15T16:00:00Z"
            }
        ]
    """
    solutions_collection = get_solutions_collection()

    # Query solutions with user and experience isolation
    cursor = solutions_collection.find(
        {"experienceId": experience_id, "userId": str(current_user["_id"])}
    ).sort("stage", 1)  # Order by processing stage (1, 2, 3)

    solutions = []
    async for solution in cursor:
        # Decrypt sensitive data for authorized user response
        decrypted_solution = decrypt_solution_data(dict(solution))
        decrypted_solution["id"] = str(solution["_id"])
        solutions.append(decrypted_solution)

    return solutions


@router.post("/{solution_id}/rate", response_model=dict)
async def rate_solution(
    solution_id: str,
    rating_data: RateSolutionRequest,
    current_user: dict = Depends(get_current_user),
):
    """
    Submit user feedback and rating for an AI-generated solution.

    This endpoint allows users to rate solutions and provide detailed feedback
    that helps improve the AI processing quality. Low ratings automatically
    trigger solution regeneration to provide better guidance.

    Authentication:
        Requires valid JWT token in Authorization header

    Args:
        solution_id (str): Unique identifier of the solution to rate
        rating_data (RateSolutionRequest): Pydantic model containing feedback
            - rating (SolutionRating): Numerical rating (0-100 scale)
            - isHelpful (bool): Whether the solution was helpful
            - improvementSuggestions (str, optional): Specific improvement feedback
            - positiveAspects (List[str], optional): What worked well
        current_user (dict): Authenticated user object injected by dependency

    Returns:
        dict: Rating confirmation and regeneration status
            - message (str): Success confirmation message
            - needsRegeneration (bool): Whether solution should be regenerated

    Raises:
        HTTPException: 400 if validation fails
        HTTPException: 401 if authentication fails
        HTTPException: 404 if solution not found or access denied
        HTTPException: 422 if rating data is invalid
        HTTPException: 500 if database operation fails

    Business Rules:
        - Users can only rate solutions for their own experiences
        - Ratings below 50% trigger automatic regeneration
        - Previous ratings are overwritten with new feedback
        - Rating timestamp is automatically set to current UTC time
        - Feedback data is encrypted before storage

    Rating Scale:
        - 0-25: Poor - Major issues, not helpful
        - 26-50: Below Average - Some issues, limited helpfulness
        - 51-75: Good - Generally helpful with minor issues
        - 76-100: Excellent - Very helpful and well-targeted

    Regeneration Logic:
        - Ratings < 50% automatically flag solution for regeneration
        - Regeneration uses original experience data with improved prompts
        - User feedback is incorporated into regeneration process

    Example Request:
        POST /api/solutions/507f1f77bcf86cd799439012/rate
        {
            "rating": 75,
            "isHelpful": true,
            "improvementSuggestions": "Could use more specific action steps",
            "positiveAspects": ["Empathetic tone", "Good emotional support"]
        }

    Example Response:
        {
            "message": "Solution rated successfully",
            "needsRegeneration": false
        }
    """
    solutions_collection = get_solutions_collection()

    # Find solution with user isolation for security
    solution = await solutions_collection.find_one(
        {"_id": ObjectId(solution_id), "userId": str(current_user["_id"])}
    )

    if not solution:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Solution not found or access denied",
        )

    # Create comprehensive feedback update document
    update_data = {
        "userFeedback": {
            "rating": rating_data.rating.value,
            "isHelpful": rating_data.isHelpful,
            "improvementSuggestions": rating_data.improvementSuggestions,
            "positiveAspects": rating_data.positiveAspects or [],
            "ratedAt": datetime.utcnow(),
        },
        "updatedAt": datetime.utcnow(),
    }

    # Encrypt sensitive feedback data before storage
    update_data = encrypt_solution_data(update_data)

    # Perform atomic update operation
    await solutions_collection.update_one(
        {"_id": ObjectId(solution_id)}, {"$set": update_data}
    )

    # Determine if solution quality is below threshold for regeneration
    needs_regeneration = rating_data.rating.value < 50

    return {
        "message": "Solution rated successfully",
        "needsRegeneration": needs_regeneration,
    }
